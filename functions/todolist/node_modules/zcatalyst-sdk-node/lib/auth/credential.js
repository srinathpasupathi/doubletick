'use strict';
var readFileSync = require('fs').readFileSync;
var resolve = require('path').resolve;
var stringify = require('querystring').stringify;
var HttpClient = require('../utils/api-request').HttpClient;
var CatalystAuthError = require('../utils/error').CatalystAuthError;
var constants = require('../utils/constants');
var CREDENTIAL_PATH = process.env.HOME
    ? resolve(resolve(process.env.HOME, '.config'), constants.CREDENTIAL_SUFFIX)
    : resolve('.', constants.CREDENTIAL_SUFFIX);
function copyAttr(to, from, key, alt) {
    var tmp = from[key] || from[alt];
    if (typeof tmp !== 'undefined') {
        to[key] = tmp;
    }
}
/*
 * Tries to load a RefreshToken from a path. If the path is not present, returns null.
 * Throws if data at the path is invalid.
 */
function fromPath(filePath) {
    var jsonString;
    try {
        jsonString = readFileSync(filePath, 'utf8');
    }
    catch (ignored) {
        // Ignore errors if the file is not present, as this is sometimes an expected condition
        return null;
    }
    try {
        return JSON.parse(jsonString);
    }
    catch (err) {
        // Throw a nicely formed error message if the file contents cannot be parsed
        throw new CatalystAuthError('invalid_credential', 'Failed to parse token file: ' + err);
    }
}
function fromEnv() {
    var jsonString;
    try {
        jsonString = process.env[constants.CATALYST_AUTH_ENV_KEY];
    }
    catch (ignored) {
        // Ignore errors if the file is not present, as this is sometimes an expected condition
        return null;
    }
    try {
        return JSON.parse(jsonString);
    }
    catch (err) {
        // Throw a nicely formed error message if the file contents cannot be parsed
        throw new CatalystAuthError('invalid_credential', 'Failed to parse refresh token string from env: ' + err);
    }
}
function requestAccessToken(client, request) {
    return client.send(request).then(function (resp) {
        var json = resp.data;
        if (json.error) {
            var errorMessage = 'Error fetching access token: ' + json.error;
            return Promise.reject(errorMessage);
        }
        else if (!json.access_token || !json.expires_in) {
            return Promise.reject("Unexpected response while fetching access token: " + JSON.stringify(json));
        }
        else {
            return json;
        }
    });
}
var RefreshToken = /** @class */ (function () {
    function RefreshToken(json) {
        copyAttr(this, json, 'clientId', 'client_id');
        copyAttr(this, json, 'clientSecret', 'client_secret');
        copyAttr(this, json, 'refreshToken', 'refresh_token');
        var errorMessage;
        if (typeof this.refreshToken !== 'string' || !this.refreshToken) {
            errorMessage = 'Refresh token must contain a "refresh_token" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new CatalystAuthError('invalid_credential', errorMessage);
        }
    }
    return RefreshToken;
}());
var AccessToken = /** @class */ (function () {
    function AccessToken(json) {
        copyAttr(this, json, 'accessToken', 'access_token');
        var errorMessage;
        if (typeof this.accessToken !== 'string' || !this.accessToken) {
            errorMessage = 'Access token must contain a "access_token" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new CatalystAuthError('invalid_credential', errorMessage);
        }
    }
    return AccessToken;
}());
var Ticket = /** @class */ (function () {
    function Ticket(json) {
        copyAttr(this, json, 'ticket', 'ticket');
        var errorMessage;
        if (typeof this.ticket !== 'string' || !this.ticket) {
            errorMessage = 'Ticket must contain a "ticket" property.';
        }
        if (typeof errorMessage !== 'undefined') {
            throw new CatalystAuthError('invalid_credential', errorMessage);
        }
    }
    return Ticket;
}());
var RefreshTokenCredential = /** @class */ (function () {
    function RefreshTokenCredential(refreshTokenObject) {
        this.refreshToken = new RefreshToken(refreshTokenObject);
        this.httpClient = new HttpClient();
    }
    RefreshTokenCredential.prototype.isTicketBasedAuth = function () {
        return false;
    };
    RefreshTokenCredential.prototype.getAccessToken = function () {
        var postData = stringify({
            client_id: this.refreshToken.clientId,
            client_secret: this.refreshToken.clientSecret,
            refresh_token: this.refreshToken.refreshToken,
            grant_type: 'refresh_token'
        });
        var request = {
            method: 'POST',
            origin: constants.ACCOUNTS_ORIGIN,
            path: '/oauth/v2/token',
            data: postData
        };
        return requestAccessToken(this.httpClient, request);
    };
    return RefreshTokenCredential;
}());
var AccessTokenCredential = /** @class */ (function () {
    function AccessTokenCredential(accessTokenObject) {
        this.accessToken = new AccessToken(accessTokenObject);
    }
    AccessTokenCredential.prototype.isTicketBasedAuth = function () {
        return false;
    };
    AccessTokenCredential.prototype.getAccessToken = function () {
        var tokenObj = {};
        tokenObj.access_token = this.accessToken.accessToken;
        return Promise.resolve(tokenObj);
    };
    return AccessTokenCredential;
}());
var TicketCredential = /** @class */ (function () {
    function TicketCredential(ticketObj) {
        this.ticket = new Ticket(ticketObj);
    }
    TicketCredential.prototype.isTicketBasedAuth = function () {
        return true;
    };
    TicketCredential.prototype.getAccessToken = function () {
        var tokenObj = {};
        tokenObj.ticket = this.ticket.ticket;
        return Promise.resolve(tokenObj);
    };
    return TicketCredential;
}());
var ObjectCredential = /** @class */ (function () {
    function ObjectCredential(obj, key, user) {
        this.adminType = obj[key][constants.CREDENTIAL_HEADER.admin_type];
        this.adminToken = obj[key][constants.CREDENTIAL_HEADER.admin_token];
        this.userType = obj[key][constants.CREDENTIAL_HEADER.user_type];
        this.userToken = obj[key][constants.CREDENTIAL_HEADER.user_token];
        if (!this.adminType || !this.adminToken || !this.userType || !this.userToken) {
            throw new CatalystAuthError('invalid_credential', 'Failed to parse request');
        }
        switch (this.adminType) {
            case constants.CREDENTIAL_TYPE.ticket:
                this.adminCred = new TicketCredential({ ticket: this.adminToken });
                break;
            case constants.CREDENTIAL_TYPE.token:
                this.adminCred = new AccessTokenCredential({
                    access_token: this.adminToken
                });
                break;
        }
        switch (this.userType) {
            case constants.CREDENTIAL_TYPE.ticket:
                this.userCred = new TicketCredential({ ticket: this.userToken });
                break;
            case constants.CREDENTIAL_TYPE.token:
                this.userCred = new AccessTokenCredential({
                    access_token: this.userToken
                });
                break;
        }
        this.user = user;
    }
    ObjectCredential.prototype.isTicketForAdmin = function () {
        if (this.adminCred instanceof TicketCredential) {
            return true;
        }
        return false;
    };
    ObjectCredential.prototype.isTicketForUser = function () {
        if (this.userCred instanceof TicketCredential) {
            return true;
        }
        return false;
    };
    ObjectCredential.prototype.isTicketBasedAuth = function () {
        switch (this.user) {
            case constants.CREDENTIAL_USER.admin:
                return this.isTicketForAdmin();
            case constants.CREDENTIAL_USER.user:
                return this.isTicketForUser();
        }
    };
    ObjectCredential.prototype.getAccessToken = function () {
        switch (this.user) {
            case constants.CREDENTIAL_USER.admin:
                return this.adminCred.getAccessToken();
            case constants.CREDENTIAL_USER.user:
                return this.userCred.getAccessToken();
        }
    };
    ObjectCredential.prototype.switchUser = function (user) {
        this.user = user;
    };
    return ObjectCredential;
}());
var ApplicationDefaultCredential = /** @class */ (function () {
    function ApplicationDefaultCredential() {
        // It is OK to not have this file. If it is present, it must be valid.
        var token = fromPath(CREDENTIAL_PATH);
        if (!token) {
            token = fromEnv();
        }
        this.ticketBased = false;
        if ('refresh_token' in token) {
            this.credential = new RefreshTokenCredential(token);
        }
        else if ('access_token' in token) {
            this.credential = new AccessTokenCredential(token);
        }
        else if ('ticket' in token) {
            this.credential = new TicketCredential(token);
            this.ticketBased = true;
        }
        return;
    }
    ApplicationDefaultCredential.prototype.isTicketBasedAuth = function () {
        return this.ticketBased;
    };
    ApplicationDefaultCredential.prototype.getAccessToken = function () {
        return this.credential.getAccessToken();
    };
    return ApplicationDefaultCredential;
}());
module.exports = {
    ApplicationDefaultCredential: ApplicationDefaultCredential,
    RefreshTokenCredential: RefreshTokenCredential,
    AccessTokenCredential: AccessTokenCredential,
    TicketCredential: TicketCredential,
    ObjectCredential: ObjectCredential
};
